<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[秋招复习：数组]]></title>
    <url>%2F2019%2F07%2F08%2F%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%EF%BC%9A%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组是由相同类型的元素组成的数据结构，分配一块连续的内存来存储，利用元素下标索引来计算对应的储存地址，几乎所有语言都支持数组。 复习索引 Java 中的数组Java 数组的本质是对象数组实例毫无疑问是对象，它可以访问 length 属性，可以调用继承自 Object 的方法。 但数组是一种特殊的类型，没有 class 文件，API 中没有对应的类，它是由 JVM 从元素类型合成出来的。 length 属性，在 JVM 中通过 arraylength 专用字节码指令访问。 数组的父类所用数组类型继承自 Object，同时，如果 B 继承自 A，则 B 的数组类型继承自 A 的数组类型。 这一点和容器不同，比如，ArrayList&lt;Number&gt; 与 ArrayList&lt;Integer&gt; 没有继承关系。 12345678910111213public class Test &#123; public static void main(String[] args) &#123; Integer[] a = new Integer[1]; System.out.println(a.getClass().getSuperclass().getName()); System.out.println(a instanceof Integer[]); System.out.println(a instanceof Number[]); &#125;&#125;output --&gt;java.lang.Objecttruetrue Java 类仅允许有一个父类，但是 getSuperclass 方法却返回了 Object，这是因为： JDK1.8 Java API public Class&lt;? super T&gt; getSuperclass() Returns the Class representing the superclass of the entity (class, interface, primitive type or void) represented by this Class. If this Class represents either the Object class, an interface, a primitive type, or void, then null is returned. If this object represents an array class then the Class object representing the Object class is returned. 如果对象是数组类型，该方法将返回 Object 对应的 Class 对象。 数组类型全名1234567891011121314151617181920212223242526public class Test &#123; public static void main(String[] args) &#123; System.out.printf("%-20s%30s\n", boolean[].class.getName(), boolean[].class.getCanonicalName()); System.out.printf("%-20s%30s\n", byte[].class.getName(), byte[].class.getCanonicalName()); System.out.printf("%-20s%30s\n", char[].class.getName(), char[].class.getCanonicalName()); System.out.printf("%-20s%30s\n", short[].class.getName(), short[].class.getCanonicalName()); System.out.printf("%-20s%30s\n", int[].class.getName(), int[].class.getCanonicalName()); System.out.printf("%-20s%30s\n", long[].class.getName(), long[].class.getCanonicalName()); System.out.printf("%-20s%30s\n", float[].class.getName(), float[].class.getCanonicalName()); System.out.printf("%-20s%30s\n", double[].class.getName(), double[].class.getCanonicalName()); System.out.printf("%-20s%30s\n", String[].class.getName(), String[].class.getCanonicalName()); System.out.printf("%-20s%30s\n", int[][][].class.getName(), int[][][].class.getCanonicalName()); &#125;&#125;output --&gt;[Z boolean[][B byte[][C char[][S short[][I int[][J long[][F float[][D double[][Ljava.lang.String; java.lang.String[][[[I int[][][] 数组特点 效率：Java 中效率最高的存储与随机访问对象引用序列的方式； 基本类型：数组可以直接持有基本类型； 定长：快速与高效的代价是数组的大小被固定。 内存中的数组数组标识符（变量）只是引用，位于栈中，它指向一个在堆中创建的实际对象，该对象用以保存指向其他对象（元素）的引用。 若元素是基本类型，则保存的是基本类型的值。 数组声明标准声明方式： 12int[] a1;int[][] a2; 但下面的形式都正确，不建议使用前三种形式，这是源自C的习惯。 1234int a1[][][]; // 1int[] a2[][]; // 2int[][] a3[]; // 3int[][][] a4; // 4 数组创建 使用 new 创建； 1int[] a = new int[1]; 使用 Array.newInstance() 静态方法，动态创建与使用数组。 12345678910public class Test &#123; public static void main(String[] args) &#123; Object array = Array.newInstance(String.class, 1); Array.set(array, 0, "abc"); System.out.println(Array.get(array, 0)); &#125;&#125;output --&gt;abc 数组初始化 静态初始化：指定初始值，系统决定数组长度。 12String[] array1 = new String[]&#123;"a", "b", "c"&#125;;String[] array2 = &#123;"a", "b", "c"&#125;; 动态初始化：指定数组大小，系统初始化默认值。 1String[] array = new String[3]; 两种方式不可同时使用。 系统初始化默认值为： 基本类型：0所对应的值，整形为0，浮点为0.0，布尔为 false，字符为空（BLANK NULL，ASCII 码编号0字符）； 引用类型：null。 初始化后，数组在内存空间中的大小固定，不可再改变。 多维数组Java 中没有多维数组，只有一维数组。或者说，所谓 Java 多维数组其实是数组的数组。 比如，三维数组中的元素其实是二维数组的引用。 因此，多维数组动态初始化时只需要指定第一维度的大小。 而且，多维数组可以为不规则（不定长）数组。 1234567public class Test &#123; public static void main(String[] args) &#123; int[][] a = new int[2][]; a[0] = new int[3]; a[1] = new int[4]; &#125;&#125; 通常，除了处理数学问题，所使用的数组最好不要超过三维。 数组大小指定Java 中数组的大小可用常量，变量，表达式等指定（需要能转换为正整数）。 而 C/C++ 只能使用常量。 数组下标Java 数组下标索引由0开始，使用 array[index] 来访问对应元素。 12int[] array = new int[1];array[0] = 9527; 入参与返回值数组是引用类型，理所当然地，可以和其他对象一样，作为入参和返回值。 泛型数组与泛型不能很好地结合。 不能实例化具有参数化类型的数组； 不允许直接创建泛型数组，但可以使用类型擦除机制与转型来获得。 1234567891011public class Test &#123; void f1() &#123; List&lt;String&gt;[] array1; // 可以声明 List&lt;String&gt;[] array2 = new List&lt;String&gt;[1]; // 不可创建，此句编译错误 &#125; &lt;T&gt; void f2() &#123; T[] array1 = new T[1]; // 不可创建，此句编译错误 T[] array2 = (T[]) new Object[1]; // 可以转型 &#125;&#125; 若要使用泛型，尽量避免使用数组，而是使用容器替代。 常见异常 数组索引超出边界； 12345678910public class Test &#123; public static void main(String[] args) &#123; int[] a = new int[1]; a[1] = 1; &#125;&#125;output --&gt;Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 1 at Test.main(Test.java:15) 指定数组大小为负数； 123456789public class Test &#123; public static void main(String[] args) &#123; int[] a = new int[-1]; &#125;&#125;output --&gt;Exception in thread "main" java.lang.NegativeArraySizeException at Test.main(Test.java:14) 数组大小超出虚拟机限制。 123456789public class Test &#123; public static void main(String[] args) &#123; int[] a = new int[Integer.MAX_VALUE]; &#125;&#125;output --&gt;Exception in thread "main" java.lang.OutOfMemoryError: Requested array size exceeds VM limit at Test.main(Test.java:14) 静态工具类 java.lang.reflect.Array：提供动态创建与访问数组的静态方法； java.util.Arrays：提供操作数组的静态实用工具方法。 其中，Arrays.asList 方法为连接数组与容器的桥梁之一；Arrays.sort 方法是一种改进后的快速排序。 数组拷贝方法 for 循环，灵活，但效率低； 继承的 clone 方法，native 原生方法，已经被覆写，浅层拷贝； Arrays.copyOf 方法，该方法实际使用了 System.arraycopy 方法，浅层拷贝； System.arraycopy 方法，native 原生方法，效率最高，浅层拷贝。 For-Each Loopfor-each 循环可适用于数组，但是其会丢掉索引信息。 12345678public class Test &#123; public static void main(String[] args) &#123; int[] a = new int[10]; for (int item : a) &#123; // do something &#125; &#125;&#125; 参考 Java编程思想 Java核心技术 JDK1.8 Java API The Java® Language Specification Java SE 8 Edition Chapter 10. Arrays 网络资源]]></content>
      <categories>
        <category>经历</category>
        <category>秋招</category>
        <category>复习</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>秋招</tag>
        <tag>复习</tag>
        <tag>临阵磨枪</tag>
        <tag>数据结构</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[秋招复习：内容索引]]></title>
    <url>%2F2019%2F07%2F07%2F%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%EF%BC%9A%E5%86%85%E5%AE%B9%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[秋招复习知识点索引梳理，个人视角，研发方向，Java主导。 君はCodingが本当に上手~ 数据结构 数组 链表 树 二叉检索树（BST） 二叉平衡树（AVL） 红黑树 B树，B+树 堆 队列 栈 图 深度优先搜索（DFS） 广度优先搜索（BFS） 最小生成树算法 迪杰斯特拉单源最短路径算法（Dijkstra） 弗洛伊德多源最短路径算法（Floyd） 基础算法 二分查找，二分变种 排序算法 冒泡 选择 快排 归并 堆 穷举法 分治法 动态规划 贪心算法 回溯法，DFS 分支限界，BFS 复杂度分析 计算机网络 TCP/IP协议栈，OSI七层模型 HTTP，HTTPS DNS TCP，UDP IP，IPV6 ARP BIO，NIO，AIO Socks5 数据库 数据库索引 SQL语法 引擎对比 数据库锁 事务 并发问题 隔离级别 优化 MySQL Redis 操作系统 进程，线程，协程，进程通讯，线程通讯 OS策略，页面置换，进程调度 死锁 虚拟内存 Linux，内核 语言 Java 基础知识 继承 异常 泛型 集合 反射，代理 并发、多线程 IO，NIO 网络编程 Java Web JVM 内存模型，机制 垃圾回收（器），GC算法 内存分配与回收策略 内存泄漏，内存溢出 类文件结构与类加载机制 线程，锁，安全 调优 JDK API，源码 HTML JavaScript 扩展 分布式 大数据 微服务 机器学习 设计模式 规范，协议，工具，框架，库 Git Maven Gradle Jenkins Nginx Apache Tomcat Docker AMQP RabbitMQ Spring JUnit MyBatis Hibernate REST 其他 LeetCode 牛客 海量数据问题 琐碎问题记录 通用基础知识 实例问题 123456789 987654321]]></content>
      <categories>
        <category>经历</category>
        <category>秋招</category>
        <category>复习</category>
      </categories>
      <tags>
        <tag>秋招</tag>
        <tag>复习</tag>
        <tag>临阵磨枪</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
