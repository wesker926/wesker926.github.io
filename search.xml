<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[秋招复习：Java 重写]]></title>
    <url>%2F2019%2F07%2F09%2F%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%EF%BC%9AJava-%E9%87%8D%E5%86%99%2F</url>
    <content type="text"><![CDATA[重写（覆写）是指子类对父类的允许访问的方法的实现过程进行重新编写，这是 Java 继承体系下多态的体现。 重写的好处是，子类可以根据自身的需要，重写实现父类的方法。 复习索引 Override 重写 / 覆写 父类的成员方法仅能被它的子类重写； 必须先继承一个方法，才能重写它； 被重写方法的方法名与重写后的方法名必须完全相同（废话）； 被重写方法的参数列表（参数顺序、类型与个数）与重写后的必须完全相同，但不包括参数名； 12345678910class A &#123; void f(int a, float b, double c) &#123; &#125;&#125;class B extends A &#123; @Override void f(int d, float e, double f) &#123; &#125;&#125; 重写方法时，访问权限修饰符的权限不能比之前更低（相同或更高），比如 protected 修饰，重写后不能为 private 或者 default权限。 因为使用父类引用时，必须保证能访问子类对象重写的方法，如果子类重写方法权限降低，那么可能导致有些父类引用无法调用方法； 123456789101112131415161718class A &#123; protected void f() &#123; &#125;&#125;class B extends A &#123; @Override public void f() &#123; // OK &#125;&#125;class C extends A &#123; @Override void f() &#123; // 默认权限，编译错误。 &#125;&#125; 关于重写方法的返回类型，在早期 Java 版本中必须相同，在 Java7 以及更高版本中可以使用协变返回类型，即为原本的类型或者原本类型的派生类，需要能够相容。 因为返回类型如果不相容，会导致此方法的调用者出现问题。 例如某方法返回 Number 类型，返回值被赋给了一个 Number 引用。当覆写时修改返回类型为 Integer，可以相容；但如果返回类型改为 String，就无法相容，String 对象无法赋予 Number 引用； 123456789101112131415161718192021class A &#123; protected Number f() &#123; return null; &#125;&#125;class B extends A &#123; @Override protected Integer f() &#123; return null; // OK &#125;&#125;class C extends A &#123; @Override protected String f() &#123; return null; // 编译错误，类型不相容。 &#125;&#125; 关于重写方法抛出的异常，重写方法可以抛出任何非受查异常，不受限制；而受查异常，重写方法仅能抛出原本声明的异常，或者范围更窄化的异常，这点和返回类型的策略相似。 调用者根据父类方法声明的异常决定处理策略（捕获或者上抛等），如果重写方法声明了更广泛的异常，将会导致该受查异常的处理被遗漏，这是不被允许的。 未抛出异常可以认为是最窄化的异常声明，所以如果父类方法抛出异常，子类重写完全可以不抛出； 123456789101112131415161718192021class A &#123; protected Number f() throws IOException &#123; return null; &#125;&#125;class B extends A &#123; @Override protected Number f() throws Exception &#123; // 编译错误，抛出异常更广泛了。 return null; &#125;&#125;class C extends A &#123; @Override protected Number f() &#123; // OK return null; &#125;&#125; 区别于依赖隐式参数的实际类型进行的动态绑定（多态），private 方法、static 方法、final 方法以及构造函数属于静态绑定，它们不能被重写。 private 方法不被继承，不能重写，但可以重新声明（从内存角度考虑，父类的一切都会被继承，但是这里使用官方文档的说法）； static 方法严格来说属于类，能够继承，不能重写，但可以重新声明（此时原静态方法被隐藏），重新声明时 static 修饰符不可移除（移除的话相当于重写了）； final 修饰方法的含义就是不能被重写，但能够继承，不存在重新声明的行为； 构造函数不能被重写。 参考 等秋招完了再补，没时间记。]]></content>
      <categories>
        <category>经历</category>
        <category>秋招</category>
        <category>复习</category>
        <category>语言</category>
        <category>Java</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>秋招</tag>
        <tag>复习</tag>
        <tag>Java</tag>
        <tag>重写</tag>
        <tag>覆写</tag>
        <tag>Override</tag>
        <tag>临阵磨枪</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[秋招复习：数组]]></title>
    <url>%2F2019%2F07%2F08%2F%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%EF%BC%9A%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组是由相同类型的元素组成的数据结构，分配一块连续的内存来存储，利用元素下标索引来计算对应的储存地址，几乎所有语言都支持数组。 复习索引 Java 中的数组Java 数组的本质是对象数组实例毫无疑问是对象，它可以访问 length 属性，可以调用继承自 Object 的方法。 但数组是一种特殊的类型，没有 class 文件，API 中没有对应的类，它是由 JVM 从元素类型合成出来的。 length 属性，在 JVM 中通过 arraylength 专用字节码指令访问。 数组的父类所用数组类型继承自 Object，同时，如果 B 继承自 A，则 B 的数组类型继承自 A 的数组类型。 这一点和容器不同，比如，ArrayList&lt;Number&gt; 与 ArrayList&lt;Integer&gt; 没有继承关系。 12345678910111213public class Test &#123; public static void main(String[] args) &#123; Integer[] a = new Integer[1]; System.out.println(a.getClass().getSuperclass().getName()); System.out.println(a instanceof Integer[]); System.out.println(a instanceof Number[]); &#125;&#125;output --&gt;java.lang.Objecttruetrue Java 类仅允许有一个父类，但是 getSuperclass 方法却返回了 Object，这是因为： JDK1.8 Java API public Class&lt;? super T&gt; getSuperclass() Returns the Class representing the superclass of the entity (class, interface, primitive type or void) represented by this Class. If this Class represents either the Object class, an interface, a primitive type, or void, then null is returned. If this object represents an array class then the Class object representing the Object class is returned. 如果对象是数组类型，该方法将返回 Object 对应的 Class 对象。 数组类型全名1234567891011121314151617181920212223242526public class Test &#123; public static void main(String[] args) &#123; System.out.printf("%-20s%30s\n", boolean[].class.getName(), boolean[].class.getCanonicalName()); System.out.printf("%-20s%30s\n", byte[].class.getName(), byte[].class.getCanonicalName()); System.out.printf("%-20s%30s\n", char[].class.getName(), char[].class.getCanonicalName()); System.out.printf("%-20s%30s\n", short[].class.getName(), short[].class.getCanonicalName()); System.out.printf("%-20s%30s\n", int[].class.getName(), int[].class.getCanonicalName()); System.out.printf("%-20s%30s\n", long[].class.getName(), long[].class.getCanonicalName()); System.out.printf("%-20s%30s\n", float[].class.getName(), float[].class.getCanonicalName()); System.out.printf("%-20s%30s\n", double[].class.getName(), double[].class.getCanonicalName()); System.out.printf("%-20s%30s\n", String[].class.getName(), String[].class.getCanonicalName()); System.out.printf("%-20s%30s\n", int[][][].class.getName(), int[][][].class.getCanonicalName()); &#125;&#125;output --&gt;[Z boolean[][B byte[][C char[][S short[][I int[][J long[][F float[][D double[][Ljava.lang.String; java.lang.String[][[[I int[][][] 数组特点 效率：Java 中效率最高的存储与随机访问对象引用序列的方式； 基本类型：数组可以直接持有基本类型； 定长：快速与高效的代价是数组的大小被固定。 内存中的数组数组标识符（变量）只是引用，位于栈中，它指向一个在堆中创建的实际对象，该对象用以保存指向其他对象（元素）的引用。 若元素是基本类型，则保存的是基本类型的值。 数组声明标准声明方式： 12int[] a1;int[][] a2; 但下面的形式都正确，不建议使用前三种形式，这是源自C的习惯。 1234int a1[][][]; // 1int[] a2[][]; // 2int[][] a3[]; // 3int[][][] a4; // 4 数组创建 使用 new 创建； 1int[] a = new int[1]; 使用 Array.newInstance() 静态方法，动态创建与使用数组。 12345678910public class Test &#123; public static void main(String[] args) &#123; Object array = Array.newInstance(String.class, 1); Array.set(array, 0, "abc"); System.out.println(Array.get(array, 0)); &#125;&#125;output --&gt;abc 数组初始化 静态初始化：指定初始值，系统决定数组长度。 12String[] array1 = new String[]&#123;"a", "b", "c"&#125;;String[] array2 = &#123;"a", "b", "c"&#125;; 动态初始化：指定数组大小，系统初始化默认值。 1String[] array = new String[3]; 两种方式不可同时使用。 系统初始化默认值为： 基本类型：0所对应的值，整形为0，浮点为0.0，布尔为 false，字符为空（BLANK NULL，ASCII 码编号0字符）； 引用类型：null。 初始化后，数组在内存空间中的大小固定，不可再改变。 多维数组Java 中没有多维数组，只有一维数组。或者说，所谓 Java 多维数组其实是数组的数组。 比如，三维数组中的元素其实是二维数组的引用。 因此，多维数组动态初始化时只需要指定第一维度的大小。 而且，多维数组可以为不规则（不定长）数组。 1234567public class Test &#123; public static void main(String[] args) &#123; int[][] a = new int[2][]; a[0] = new int[3]; a[1] = new int[4]; &#125;&#125; 通常，除了处理数学问题，所使用的数组最好不要超过三维。 数组大小指定Java 中数组的大小可用常量，变量，表达式等指定（需要能转换为正整数）。 而 C/C++ 只能使用常量。 数组下标Java 数组下标索引由0开始，使用 array[index] 来访问对应元素。 12int[] array = new int[1];array[0] = 9527; 入参与返回值数组是引用类型，理所当然地，可以和其他对象一样，作为入参和返回值。 泛型数组与泛型不能很好地结合。 不能实例化具有参数化类型的数组； 不允许直接创建泛型数组，但可以使用类型擦除机制与转型来获得。 1234567891011public class Test &#123; void f1() &#123; List&lt;String&gt;[] array1; // 可以声明 List&lt;String&gt;[] array2 = new List&lt;String&gt;[1]; // 不可创建，此句编译错误 &#125; &lt;T&gt; void f2() &#123; T[] array1 = new T[1]; // 不可创建，此句编译错误 T[] array2 = (T[]) new Object[1]; // 可以转型 &#125;&#125; 若要使用泛型，尽量避免使用数组，而是使用容器替代。 常见异常 数组索引超出边界； 12345678910public class Test &#123; public static void main(String[] args) &#123; int[] a = new int[1]; a[1] = 1; &#125;&#125;output --&gt;Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 1 at Test.main(Test.java:15) 指定数组大小为负数； 123456789public class Test &#123; public static void main(String[] args) &#123; int[] a = new int[-1]; &#125;&#125;output --&gt;Exception in thread "main" java.lang.NegativeArraySizeException at Test.main(Test.java:14) 数组大小超出虚拟机限制。 123456789public class Test &#123; public static void main(String[] args) &#123; int[] a = new int[Integer.MAX_VALUE]; &#125;&#125;output --&gt;Exception in thread "main" java.lang.OutOfMemoryError: Requested array size exceeds VM limit at Test.main(Test.java:14) 静态工具类 java.lang.reflect.Array：提供动态创建与访问数组的静态方法； java.util.Arrays：提供操作数组的静态实用工具方法。 其中，Arrays.asList 方法为连接数组与容器的桥梁之一；Arrays.sort 方法是一种改进后的快速排序。 数组拷贝方法 for 循环，灵活，但效率低； 继承的 clone 方法，native 原生方法，已经被覆写，浅层拷贝； Arrays.copyOf 方法，该方法实际使用了 System.arraycopy 方法，浅层拷贝； System.arraycopy 方法，native 原生方法，效率最高，浅层拷贝。 For-Each Loopfor-each 循环可适用于数组，但是其会丢掉索引信息。 12345678public class Test &#123; public static void main(String[] args) &#123; int[] a = new int[10]; for (int item : a) &#123; // do something &#125; &#125;&#125; 参考 等秋招完了再补，没时间记。]]></content>
      <categories>
        <category>经历</category>
        <category>秋招</category>
        <category>复习</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>秋招</tag>
        <tag>复习</tag>
        <tag>临阵磨枪</tag>
        <tag>数据结构</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[秋招复习：内容索引]]></title>
    <url>%2F2019%2F07%2F07%2F%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%EF%BC%9A%E5%86%85%E5%AE%B9%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[秋招复习知识点索引梳理，个人视角，研发方向，Java主导。 君はCodingが本当に上手~ 数据结构 数组 链表 树 二叉检索树（BST） 二叉平衡树（AVL） 红黑树 B 树，B+ 树 堆 队列 栈 图 深度优先搜索（DFS） 广度优先搜索（BFS） 最小生成树算法 迪杰斯特拉单源最短路径算法（Dijkstra） 弗洛伊德多源最短路径算法（Floyd） 基础算法 二分查找，二分变种 排序算法 冒泡 选择 快排 归并 堆 穷举法 分治法 动态规划 贪心算法 回溯法，DFS 分支限界，BFS 复杂度分析 计算机网络 TCP/IP 协议栈，OSI 七层模型 HTTP，HTTPS DNS TCP，UDP IP，IPV6 ARP BIO，NIO，AIO Socks5 数据库 索引 SQL 语法 引擎 事务 ACID特性 并发控制机制 数据库锁机制 加锁协议 隔离级别 优化 MySQL Redis 操作系统 进程，线程，协程，进程通讯，线程通讯 OS 策略，页面置换，进程调度 死锁 虚拟内存 Linux，内核 语言 Java 基础知识 Override 重写 继承 异常 泛型 集合 反射，代理 并发、多线程 IO，NIO 网络编程 Java Web JVM 内存模型，机制 垃圾回收（器），GC 算法 内存分配与回收策略 内存泄漏，内存溢出 类文件结构与类加载机制 线程，锁，安全 调优 JDK API，源码 HTML JavaScript 扩展 分布式 大数据 微服务 机器学习 设计模式 规范，协议，工具，框架，库 Git Maven Gradle Jenkins Nginx Apache Tomcat Docker AMQP RabbitMQ Spring JUnit MyBatis Hibernate REST 其他 LeetCode 牛客 海量数据问题 琐碎知识记录 通用基础知识 正则表达式 原码，反码，补码 实例问题 从输入URL到页面加载完成，中间发生了什么。 2 3 4 5]]></content>
      <categories>
        <category>经历</category>
        <category>秋招</category>
        <category>复习</category>
      </categories>
      <tags>
        <tag>秋招</tag>
        <tag>复习</tag>
        <tag>临阵磨枪</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
